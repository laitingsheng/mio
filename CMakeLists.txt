cmake_minimum_required(VERSION 3.8)

#
# Here we check whether mio is being configured in isolation or as a component
# of a larger project. To do so, we query whether the `PROJECT_NAME` CMake
# variable has been defined. In the case it has, we can conclude mio is a
# subproject.
#
# This convention has been borrowed from the Catch C++ unit testing library.
#
if(DEFINED PROJECT_NAME)
	set(subproject ON)
	if(NOT DEFINED INSTALL_SUBPROJECTS)
		set(INSTALL_SUBPROJECTS ON CACHE BOOL "Install subproject dependencies")
	endif()
else()
	set(subproject OFF)
	set_property(GLOBAL PROPERTY USE_FOLDERS ON)
endif()

project(mio VERSION 2.0 LANGUAGES C CXX)
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/cmake")
include(CMakeDependentOption)
include(CMakePackageConfigHelpers)
include(CTest)
include(GNUInstallDirs)

# Generate 'compile_commands.json' for clang_complete
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# mio requires at least C++11 support.
if (CMAKE_CXX_STANDARD LESS 11)
	set(CMAKE_CXX_STANDARD 11)
endif ()
set(CMAKE_CXX_EXTENSIONS OFF)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

#
# The `mio.testing` options only appear as cmake-gui and ccmake options iff
# mio is the highest level project. In the case that mio is a subproject, these
# options are hidden from the user interface and set to `OFF`
#
# Iff mio is the highest level project, this option is defaulted to the value
# of the traditional course grain testing option `BUILD_TESTING` established by
# the CTest module
#
CMAKE_DEPENDENT_OPTION(mio.tests
	"Build the mio tests and integrate with ctest"
	ON "BUILD_TESTING; NOT subproject" OFF)

#
# When the end user is consuming mio as a nested subproject, an option
# is provided such that the user may exlude mio from the set of installed
# cmake projects. This accomodates end users building executables or
# compiled libraries which privately link to mio, but wish to only ship their
# artifacts in an installation
#
CMAKE_DEPENDENT_OPTION(mio.installation
	"Include mio in the install set"
	"${INSTALL_SUBPROJECTS}" "subproject" ON)
mark_as_advanced(mio.installation)

#
# mio has no compiled components. As such, we declare it as an `INTERFACE`
# library, which denotes a collection of target properties to be applied
# transitively to linking targets. In our case, this amounts to an include
# directory and (potentially) some preprocessor definitions.
#
add_library(mio INTERFACE)
add_library(mio::mio ALIAS mio)

#
# The include directory for mio can be expected to vary between build
# and installaion. Here we use a CMake generator expression to dispatch
# on how the configuration under which this library is being consumed.
#
# We define the generator expression as a variable, such that the logic
# need not be repeated when populating source file paths.
#
string(CONCAT prefix
	"$<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/include>"
	"$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>")

target_include_directories(mio INTERFACE ${prefix})

if(mio.tests)
	add_subdirectory(test)
endif()

if(mio.installation)
	#
	# Non-testing header files (preserving relative paths) are installed to the
	# `include` subdirectory of the `$INSTALL_DIR/${CMAKE_INSTALL_PREFIX}`
	# directory. Source file permissions preserved.
	#
	install(DIRECTORY include/
		DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}"
		FILES_MATCHING PATTERN "*.*pp")

	#
	# As a header-only library, there are no target components to be installed
	# directly (the PUBLIC_HEADER property is not white listed for INTERFACE
	# targets for some reason).
	#
	# However, it is worthwhile export our target description in order to later
	# generate a CMake configuration file for consumption by CMake's `find_package`
	# intrinsic
	#
	install(TARGETS mio EXPORT mioTargets)

	install(EXPORT mioTargets
		FILE mio-targets.cmake
		NAMESPACE mio::
		DESTINATION share/cmake/mio)

	write_basic_package_version_file("mio-config-version.cmake"
		VERSION ${PROJECT_VERSION}
		COMPATIBILITY SameMajorVersion)

	configure_file(
		"${PROJECT_SOURCE_DIR}/cmake/mio-config.cmake.in"
		"${PROJECT_BINARY_DIR}/mio-config.cmake"
		@ONLY)

	install(FILES
		"${PROJECT_BINARY_DIR}/mio-config-version.cmake"
		"${PROJECT_BINARY_DIR}/mio-config.cmake"
		DESTINATION share/cmake/mio)

	#
	# Rudimentary CPack support.
	#
	# CPack provides a mechanism to generate installation packaging for a project,
	# e.g., self-extracting shell scripts, compressed tarballs, Debian Package files,
	# RPM Package Manager files, Windows NSIS installation wizards,
	# Apple Disk Images (.dmg), etc.
	#
	# A packaged installation can be generated by calling
	#
	# ```sh
	# cpack -G <packaging type> --config CPackConfig.cmake
	# ```
	#
	# See `cpack --help` or the CPack documentation for more information.
	#
	if(NOT subproject)
		set(CPACK_PACKAGE_VENDOR "mandreyel")
		set(CPACK_PACKAGE_DESCRIPTION_SUMMARY
			"Cross-platform C++11 header-only library for memory mapped file IO")
		set(CMAKE_PROJECT_HOMEPAGE_URL "https://github.com/mandreyel/mio")
		set(CPACK_RESOURCE_FILE_LICENSE "${PROJECT_SOURCE_DIR}/LICENSE")
		set(CPACK_PACKAGE_VERSION_MAJOR "${PROJECT_VERSION_MAJOR}")
		set(CPACK_PACKAGE_VERSION_MINOR "${PROJECT_VERSION_MINOR}")
		set(CPACK_PACKAGE_VERSION_PATCH "${PROJECT_VERSION_PATCH}")
		include(CPack)
	endif()
endif()
